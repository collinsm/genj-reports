/**
 * Some of this code stolen from ReportDescendants.java.
 * Michael Collins <mikec01b@netscape.net>
 * $Header: /shared/cvs/genj/report/ReportHTMLList.java,v 1.4 2004/05/31 16:07:18 mikec01 Exp $
 */
 
import genj.gedcom.*;
import genj.report.Report;
import genj.util.Origin;
import java.util.*;
import java.io.*;
// new stuff for createThumbnail()...
import java.awt.Image;
import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import com.sun.image.codec.jpeg.JPEGCodec;
import com.sun.image.codec.jpeg.JPEGImageEncoder;

/**
 * This class reads the following tags from entities in the GEDCOM file:
 * <ul>
 * <li>INDI:BIRT:DATE
 * <li>INDI:BIRT:PLAC
 * <li>INDI:DEAT:DATE
 * <li>INDI:DEAT:PLAC
 * <li>INDI:DSCR
 * <li>INDI:EMIG
 * <li>INDI:EMIG:DATE
 * <li>INDI:EMIG:NOTE
 * <li>INDI:EMIG:PLAC
 * <li>INDI:IMMI
 * <li>INDI:IMMI:DATE
 * <li>INDI:IMMI:NOTE
 * <li>INDI:IMMI:PLAC
 * <li>INDI:NAME
 * <li>INDI:NATI
 * <li>INDI:NATI:NOTE
 * <li>INDI:NOTE
 * <li>INDI:OBJE
 * <li>INDI:OBJE:FILE
 * <li>INDI:OBJE:FORM
 * <li>INDI:OBJE:TITL
 * </ul>
 */
public class ReportHTMLList extends Report {
	
	/**
	 * Returns the version of this report.
	 */
	public String getVersion() {
		return( i18n( "version" ));
	}
	
	/**
	 * Returns the name of this report.
	 */
	public String getName() {
		return( i18n( "name" ));
	}
	
	/**
	 * Get some information about this report.
	 * @return Information as string.
	 */
	public String getInfo() {
		return( i18n( "info" ));
	}
	
	public String strOutputDir = java.lang.System.getProperty(
		"java.io.tmpdir", "/tmp/" );
		
	/**
	 * Return the author information.
	 */
	public String getAuthor() {
		return( "Michael Collins <mikec01b@netscape.net>" );
	}
	
	/**
	 * @see genj.report.Report#accepts(java.lang.Object)
	 */
	public String accepts( Object context ) {
		return context instanceof Gedcom ? getName() : null;
	}

	private int dotCount = 0;

	/**
	 * Specifies the maximum height or width to be applied to a thumbnail
	 * image.  This number is sent to the createThumbnail() method.
	 */
	private int THUMB_SIZE = 100;
	
	/**
	 * Specifies whether debugging information will be written to stdout.
	 */	
	private boolean DEBUG = false;
	
	/**
	 * Internal class: custom Comparator
	 */
	class HTMLListComparator implements Comparator {
		public int compare( Object a, Object b ) {
			String aStr, bStr;
			aStr = a.toString();
			bStr = b.toString();
			return aStr.compareTo( bStr );
		}
	}
		
	/**
	 * Start the report.
	 */
	public void start( Object context ) {
		if( ! ( context instanceof Gedcom )) {
			return;
		}
		Gedcom gedcom = ( Gedcom )context;
		
		buildHtmlSkeleton();
		
		String pathSep = System.getProperty( "file.separator" );
		
		// Erase the 'I' directory recursively.  This should close Bug 1.
		// Warning: don't delete the "std" directory.  Files in "std" do NOT
		//  get regenerated by this report.
		if( deleteDir( new File( strOutputDir + pathSep + "I" ))) {
			println( "The I directory has been removed!" );
		} else {
			println( "Failure to clean output directory..." );
		}
		
		String nodes_js = strOutputDir + pathSep + "Nodes.js";
		OutputStream os = null;
		PrintWriter pw = null;
		try {
			os = new FileOutputStream( nodes_js );
			pw = new PrintWriter( os );
			pw.println( "USETEXTLINKS = 1" );
			pw.println( "STARTALLOPEN = 0" );
			pw.println( "ICONPATH = 'std/'" );
			pw.println( "foldersTree = gFld(\"<i>Family Viewer - Introduction</i>\", \"_intro.html\")" );
		} catch( Exception e ) {
			println( "Caught exception: " + e );
		}

		// all the entities...
		Entity[] aryEntities = gedcom.getEntities( genj.gedcom.Gedcom.INDI,
			new HTMLListComparator() );
		
		// find the first root entry...
		for( int i = 0; i < aryEntities.length; i ++ ) {
			Object element = aryEntities[ i ];
			Indi indi = ( Indi )element;
			if( null == indi.getFamc() ) {
				walkTree( indi, 1, pw );
			}
		}
		pw.close();
		println( "done!" );
	}
	
	/**
	 * For a given individual, dump all descendants.  This is recursive.
	 */
	private void walkTree( Indi indi, int level, PrintWriter pw ) {
		String parentFolder = (level == 1 ) ? "foldersTree" : "aux" + (level-1);
		if( dotCount++ >= 20 ) {
			println( "..." );
			dotCount = 0;
		}
		int ctFamilies = indi.getNoOfFams();
		if( 0 == ctFamilies ) {
			//println( indi.getName() + ": No families - making doc" );
			pw.println( "insDoc(" + parentFolder + ", gLnk(\"R\", \"" +
				indi.getName() + "\", \"" + getIndiHtml( indi.getId()) + "\"))" );
		} else {
			//println( indi.getName() + ": Some children in family " +
			//	".  Making folder" );
			pw.println( "aux" + level + "=insFld(" + parentFolder +
				", gFld(\"" + indi.getName() + "\", \"" + getIndiHtml( indi.getId()) +
				"\"))" );
		}
		
		writeIndiHTML( indi );
		
		for( int f = 0; f < ctFamilies; f ++ ) {
			Fam family = indi.getFam( f );
			
			// BUGBUG: getChildren() is not sorted.  I could create a new
			//	ArrayList with a Comparator (above) and move each element of
			//	this array into it.
			Indi[] children = family.getChildren();
			for( int c = 0; c < children.length; c ++ ) {
				walkTree( children[c], level + 1, pw );
			}	// child loop
		}	// family loop
	}

	/**
	 * Inserts slashes into the Individual's ID, and appends an HTML file
	 * name suffix.  The slashes will break these up into directories, to
	 * hopefully speed things up a bit.
	 *
	 * Bug#51 -- make this four levels deep.
	 */
	private String getIndiHtml( String sID ) {
		String out = "";				// assume sID = "I123"
		out += sID.charAt(0) + "/";		// I/
		out += sID.charAt(1) + "/";		// I/1/
		out += sID.charAt(2) + "/";		// I/1/2/
		out += sID.substring(3);		// I/1/2/3
		out += ".html";					// I/1/2/3.html
		return out;
	}
	
	/**
	 * Return the Individual's name.
	 * Tag: INDI:NAME
	 */
	private String getName( Indi indi ) {
		return indi.getName();
	}
	
	/**
	 * Return the Individual's entity ID (I-number).
	 */
	private String getEntityID( Indi indi ) {
		return indi.getId();
	}
	
	/**
	 * Returns a boolean stating whether the Individual has a Nationality
	 * tag or not.
	 * Tag: INDI:NATI
	 * @return true if Nationality exists, false otherwise.
	 */
	private boolean hasNationality( Indi indi ) {
		Property pn = indi.getProperty( new TagPath( "INDI:NATI" ));
		return( null != pn );
	}
	
	/**
	 * Returns the Individual's Nationality, or the string "Error" if the
	 * Nationality does not exist.
	 * Tag: INDI:NATI
	 */
	private String getNationality( Indi indi ) {
		Property pn = indi.getProperty( new TagPath( "INDI:NATI" ));
		if( pn != null ) {
			return( pn.getValue() );
		}
		return( "Error" );
	}
	
	/**
	 * Returns a boolean stating whether the Individual has a Description
	 * tag or not.
	 * Tag: INDI:DSCR
	 * @return true if Description exists, false otherwise.
	 */
	private boolean hasDescription( Indi indi ) {
		Property pd = indi.getProperty( new TagPath( "INDI:DSCR" ));
		return( null != pd );
	}
	
	/**
	 * Returns the Individual's Description, or the string "Error" if the
	 * Description does not exist.
	 * Tag: INDI:DSCR
	 */
	private String getDescription( Indi indi ) {
		Property pd = indi.getProperty( new TagPath( "INDI:DSCR" ));
		if( pd != null ) {
			return( pd.getValue() );
		}
		return( "Error" );
	}
	
	/**
	 * Returns the birth date (as a string) of the Individual.
	 * Tag: INDI:BIRT:DATE
	 */
	private String getBirthDate( Indi indi ) {
		return indi.getBirthAsString();
	}
	
	/**
	 * Returns the death date (as a string) of the Individual.
	 * Tag: INDI:DEAT:DATE
	 */
	private String getDeathDate( Indi indi ) {
		return indi.getDeathAsString();
	}
	
	/**
	 * Returns a boolean stating whether the Individual has birth place
	 * information.  The Individual is not considered to have birth place
	 * information if the tag exists and is empty.
	 * Tag: INDI:BIRT:PLAC
	 * @return true if Birth Place information exists, false otherwise.
	 */
	private boolean hasBirthPlace( Indi indi ) {
		Property pbp = indi.getProperty( new TagPath( "INDI:BIRT:PLAC" ));
		if( null != pbp ) {
			String sbp = pbp.getValue();
			if( !sbp.equals( "" )) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Returns a boolean stating whether the Individual has death place
	 * information.  The Individual is not considered to have death place
	 * information if the tag exists and is empty.
	 * Tag: INDI:DEAT:PLAC
	 * @return true if Death Place information exists, false otherwise.
	 */
	private boolean hasDeathPlace( Indi indi ) {
		Property pbp = indi.getProperty( new TagPath( "INDI:DEAT:PLAC" ));
		if( null != pbp ) {
			String sbp = pbp.getValue();
			if( !sbp.equals( "" )) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Returns the place of birth for the Individual.
	 * Tag: INDI:BIRT:PLAC
	 */
	private String getBirthPlace( Indi indi ) {
		Property pbp = indi.getProperty( new TagPath( "INDI:BIRT:PLAC" ));
		String sbp = "";
		if( null != pbp ) {
			sbp = pbp.getValue();
		}
		return( sbp );
	}

	/**
	 * Returns the place of death for the Individual.
	 * Tag: INDI:DEAT:PLAC
	 */
	private String getDeathPlace( Indi indi ) {
		Property pbp = indi.getProperty( new TagPath( "INDI:DEAT:PLAC" ));
		String sbp = "";
		if( null != pbp ) {
			sbp = pbp.getValue();
		}
		return( sbp );
	}

	/**
	 * Returns a boolean stating whether this Individual has multiple names
	 * or not.
	 * Tag: INDI:NAME
	 * @return true if there is more than one NAME tag associated with this
	 * individual.
	 */
	private boolean hasAliases( Indi indi ) {
		Property[] apn = indi.getProperties( "NAME" );
		return( apn.length > 1 );
	}
	
	/**
	 * Returns a list of aliases (NAMEs other than the primary) for this
	 * individual.
	 * Tag: INDI:NAME
	 */
	private String[] getAliases( Indi indi ) {
		Property[] apn = indi.getProperties( "NAME" );
		String[] out = new String[apn.length - 1];
		for( int i = 1; i < apn.length; i++ ) {
			if( apn[i] instanceof PropertyName ) {
				PropertyName pn = ( PropertyName ) apn[i];
				out[i-1] = pn.getName();
			}
		}
		return out;
	}
	
	/**
	 * Returns a boolean stating whether this Individual has Note entries
	 * or not.
	 * Tag: INDI:NOTE
	 * @return true if there are one or more NOTE tags associated with this
	 * individual, false if none.
	 */
	private boolean hasNotes( Indi indi ) {
		Property[] apn = indi.getProperties( "NOTE" );
		return( apn.length > 0 );
	}
	
	/**
	 * Returns a list of Notes associated with this individual.
	 * Tag: INDI:NOTE
	 * Please be aware that these notes are ONLY at the individual level.
	 */
	private String[] getNotes( Indi indi ) {
		Property[] apn = indi.getProperties( "NOTE" );
		String[] out = new String[apn.length];
		for( int i = 0; i < apn.length; i++ ) {
			if( apn[i] instanceof PropertyMultilineValue ) {
				PropertyMultilineValue pmv = ( PropertyMultilineValue ) apn[i];
				out[i] = pmv.getLinesValue();
			}
		}
		return out;
	}
	
	/**
	 * Returns a boolean stating whether this Individual has Emigration info
	 * associated with it or not.
	 * Tag: INDI:EMIG
	 */
	private boolean hasEmigration( Indi indi ) {
		Property pe = indi.getProperty( "EMIG" );
		return( pe != null );
	}
	
	/**
	 * Returns a boolean stating whether this Individual has Immigration info
	 * associated with it or not.
	 * Tag: INDI:IMMI
	 */
	private boolean hasImmigration( Indi indi ) {
		Property pi = indi.getProperty( "IMMI" );
		return( pi != null );
	}

	/**
	 * Returns a boolean stating whether this Individual has an Emigration
	 * Place associated with it or not.
	 * Tag: INDI:EMIG:PLAC
	 */
	private boolean hasEmigrationPlace( Indi indi ) {
		Property pep = indi.getProperty( "EMIG" ).getProperty( "PLAC" );
		return( pep.getValue().compareTo("") != 0 );
	}

	/**
	 * Returns a string containing this Individual's Emigration Place.
	 * Tag: INDI:EMIG:PLAC
	 */
	private String getEmigrationPlace( Indi indi ) {
		Property pep = indi.getProperty( "EMIG" ).getProperty( "PLAC" );
		return( pep.getValue() );
	}

	/**
	 * Returns a boolean stating whether this Individual has an Immigration
	 * Place associated with it or not.
	 * Tag: INDI:IMMI:PLAC
	 */
	private boolean hasImmigrationPlace( Indi indi ) {
		Property pip = indi.getProperty( "IMMI" ).getProperty( "PLAC" );
		return( pip.getValue().compareTo("") != 0 );
	}

	/**
	 * Returns a string containing this Individual's Immigration Place.
	 * Tag: INDI:IMMI:PLAC
	 */
	private String getImmigrationPlace( Indi indi ) {
		Property pip = indi.getProperty( "IMMI" ).getProperty( "PLAC" );
		return( pip.getValue() );
	}

	/**
	 * Returns a boolean stating whether this Individual has Emigration
	 * Notes associated with it or not.
	 * Tag: INDI:EMIG:NOTE
	 */
	private boolean hasEmigrationNotes( Indi indi ) {
		Property[] pep = indi.getProperty( "EMIG" ).getProperties( "NOTE" );
		return( pep.length > 0 );
	}

	/**
	 * Returns a string containing this Individual's Emigration Notes.
	 * Tag: INDI:EMIG:NOTE
	 */
	private String[] getEmigrationNotes( Indi indi ) {
		Property[] pep = indi.getProperty( "EMIG" ).getProperties( "NOTE" );
		String[] out = new String[pep.length];
		for( int i = 0; i < pep.length; i++ ) {
			if( pep[i] instanceof PropertyMultilineValue ) {
				PropertyMultilineValue pmv = ( PropertyMultilineValue ) pep[i];
				out[i] = pmv.getLinesValue();
			}
		}
		return( out );
	}

	/**
	 * Returns a boolean stating whether this Individual has Immigration
	 * Notes associated with it or not.
	 * Tag: INDI:IMMI:NOTE
	 */
	private boolean hasImmigrationNotes( Indi indi ) {
		Property[] pip = indi.getProperty( "IMMI" ).getProperties( "NOTE" );
		return( pip.length > 0 );
	}

	/**
	 * Returns a string containing this Individual's Immigration Notes.
	 * Tag: INDI:IMMI:NOTE
	 */
	private String[] getImmigrationNotes( Indi indi ) {
		Property[] pip = indi.getProperty( "IMMI" ).getProperties( "NOTE" );
		String[] out = new String[pip.length];
		for( int i = 0; i < pip.length; i++ ) {
			if( pip[i] instanceof PropertyMultilineValue ) {
				PropertyMultilineValue pmv = ( PropertyMultilineValue ) pip[i];
				out[i] = pmv.getLinesValue();
			}
		}
		return( out );
	}

	/**
	 * Returns a boolean stating whether this Individual has an Emigration
	 * Date associated with it or not.
	 * Tag: INDI:EMIG:DATE
	 */
	private boolean hasEmigrationDate( Indi indi ) {
		Property pep = indi.getProperty( "EMIG" ).getProperty( "DATE" );
		return( pep.getValue().compareTo("") != 0 );
	}

	/**
	 * Returns a string containing this Individual's Emigration Date.
	 * Tag: INDI:EMIG:DATE
	 */
	private String getEmigrationDate( Indi indi ) {
		Property pep = indi.getProperty( "EMIG" ).getProperty( "DATE" );
		return( pep.getValue() );
	}

	/**
	 * Returns a boolean stating whether this Individual has an Immigration
	 * Date associated with it or not.
	 * Tag: INDI:IMMI:DATE
	 */
	private boolean hasImmigrationDate( Indi indi ) {
		Property pip = indi.getProperty( "IMMI" ).getProperty( "DATE" );
		return( pip.getValue().compareTo("") != 0 );
	}

	/**
	 * Returns a string containing this Individual's Immigration Date.
	 * Tag: INDI:IMMI:DATE
	 */
	private String getImmigrationDate( Indi indi ) {
		Property pip = indi.getProperty( "IMMI" ).getProperty( "DATE" );
		return( pip.getValue() );
	}

	/**
	 * Returns a boolean stating whether this Individual has a Father
	 * entry.  If the Individual doesn't have a parent family, s/he
	 * doesn't have a Father either.
	 * Tag: INDI:FAMC:HUSB
	 */
	private boolean hasFather( Indi indi ) {
		Fam famc = indi.getFamc();
		if( null == famc ) {
			return false;
		}
		Indi father = famc.getHusband();
		if( null == father ) {
			return false;
		}
		return true;
	}
	
	/**
	 * Returns the name of this Individual's Father.
	 * Tag: INDI:FAMC:HUSB
	 */
	private String getFatherName( Indi indi ) {
		Fam famc = indi.getFamc();
		if( null != famc ) {
			Indi father = famc.getHusband();
			if( null != father ) {
				return( father.getName() );
			}
		}
		return( null );
	}
	
	/**
	 * Returns an HREF-able filename for the father.
	 */
	private String getFatherHref( Indi indi ) {
		Fam famc = indi.getFamc();
		if( null != famc ) {
			Indi father = famc.getHusband();
			if( null != father ) {
				return( "../../../" + getIndiHtml( father.getId() ));
			}
		}
		return( null );
	}
	
	/**
	 * Returns a boolean stating whether this Individual has a Mother
	 * entry.  If the Individual doesn't have a parent family, s/he
	 * doesn't have a Mother either.
	 * Tag: INDI:FAMC:WIFE
	 */
	private boolean hasMother( Indi indi ) {
		Fam famc = indi.getFamc();
		if( null == famc ) {
			return false;
		}
		Indi mother = famc.getWife();
		if( null == mother ) {
			return false;
		}
		return true;
	}
	
	/**
	 * Returns the name of this Individual's Mother.
	 * Tag: INDI:FAMC:WIFE
	 */
	private String getMotherName( Indi indi ) {
		Fam famc = indi.getFamc();
		if( null != famc ) {
			Indi mother = famc.getWife();
			if( null != mother ) {
				return( mother.getName() );
			}
		}
		return( null );
	}
	
	/**
	 * Returns an HREF-able filename for the mother.
	 */
	private String getMotherHref( Indi indi ) {
		Fam famc = indi.getFamc();
		if( null != famc ) {
			Indi mother = famc.getWife();
			if( null != mother ) {
				return( "../../../" + getIndiHtml( mother.getId() ));
			}
		}
		return( null );
	}
	
	/**
	 * Returns a TreeSet of siblings of this Individual.
	 */
	private TreeSet getSiblings( Indi indi ) {
		if( DEBUG ) {
			println( "getSiblings() entered" );
		}
		TreeSet tsOut = new TreeSet();
		Fam famc = indi.getFamc();
		if( famc != null ) {
			Indi father = famc.getHusband();
			Indi mother = famc.getWife();
			if( father != null ) {
				Indi[] sibs = father.getChildren();
				for( int i = 0; i < sibs.length; i++ ) {
					if( !sibs[i].getId().equals( indi.getId() )) {
						tsOut.add( sibs[i] );
					}
				}
			}
			if( mother != null ) {
				Indi[] sibs = mother.getChildren();
				for( int i = 0; i < sibs.length; i++ ) {
					if( !sibs[i].getId().equals( indi.getId() )) {
						tsOut.add( sibs[i] );
					}
				}
			}
		}
		if( DEBUG ) {
			println( "getSiblings() returning" );
		}
		return( tsOut );
	}
	
	/**
	 * Returns a boolean stating whether this Individual has any siblings.
	 */
	private boolean hasSiblings( Indi indi ) {
		TreeSet tsSibs = getSiblings( indi );
		return( tsSibs.size() > 0 );
	}
	
	/**
	 * Returns a TreeSet of children of this Individual, and all this
	 * Individual's spouses.
	 * @param indi The individual to find the children of.
	 * @return TreeSet containing all the children of this Individual
	 *  and his/her spouses.
	 */
	private TreeSet getChildren( Indi indi ) {
		if( DEBUG ) {
			println( "getChildren() entered" );
		}
		TreeSet tsOut = new TreeSet();
		Indi[] kids = indi.getChildren();
		for( int i = 0; i < kids.length; i++ ) {
			tsOut.add( kids[i] );
		}
		TreeSet ts = getSpouses( indi );
		Iterator iSps = ts.iterator();
		while( iSps.hasNext() ) {
			Indi sps = (Indi)iSps.next();
			Indi[] kids2 = sps.getChildren();
			for( int j = 0; j < kids2.length; j++ ) {
				tsOut.add( kids2[j] );
			}
		}
		if( DEBUG ) {
			println( "getChildren() returning" );
		}
		return( tsOut );
	}
	
	/**
	 * Returns a boolean stating whether this Individual has any children.
	 */
	private boolean hasChildren( Indi indi ) {
		TreeSet tsChildren = getChildren( indi );
		return( tsChildren.size() > 0 );
	}
	
	/**
	 * Returns a TreeSet of spouses for this Individual.
	 */
	private TreeSet getSpouses( Indi indi ) {
		if( DEBUG ) {
			println( "getSpouses() entered" );
		}
		TreeSet tsOut = new TreeSet();
		Fam[] fams = indi.getFamilies();
		for( int i = 0; i < fams.length; i++ ) {
			Indi spouse = fams[i].getOtherSpouse( indi );
			if( null != spouse ) {
//				println( "For " + indi.getId() + ", adding spouse "
//					+ spouse.getId() + "\n" );
				tsOut.add( spouse );
			}
		}
		if( DEBUG ) {
			println( "getSpouses() returning" );
		}
		return( tsOut );
	}
	
	/**
	 * Returns a boolean stating whether this Individual has any spouses.
	 */
	private boolean hasSpouses( Indi indi ) {
		if( DEBUG ) {
			println( "hasSpouses() entered" );
		}
		TreeSet tsSpouses = getSpouses( indi );
		if( DEBUG ) {
			println( "hasSpouses() returning" );
		}
		return( tsSpouses.size() > 0 );
	}
	
	/**
	 * Return name information for the Individual.
	 */
	private String getNameInfo( Indi indi ) {
		String out = "";
		out += "<b>" + indi.getId() + "</b> " + indi.getName() + "<br>";
		
		Property[] names = indi.getProperties( "NAME" );
		if( names.length > 1 ) {
			for( int j = 1; j < names.length; j++ ) {
				if( names[j] instanceof PropertyName ) {
					PropertyName pn = ( PropertyName ) names[j];
					out += pn.getName() + "<br>";
				}
			}
		}
		
		Property pNATI = indi.getProperty( new TagPath( "INDI:NATI" ));
		if( null != pNATI ) {
			out += "Nationality: " + pNATI.getValue() + "<br>";
			Property pNote = indi.getProperty( new TagPath( "INDI:NATI:NOTE" ));
			if( null != pNote ) {
//				out += "Note: " + pNote.getValue() + "<br>";
			}
		}
		
		Property pDSCR = indi.getProperty( new TagPath( "INDI:DSCR" ));
		if( null != pDSCR ) {
			out += "Description: " + pDSCR.getValue() + "<br>";
		}
		
		return out;
	}
	
	/**
	 * Get birth and death information for an Individual.
	 */
	private String getBirthDeathInfo( Indi indi ) {
		String out = "";
		Property bPlace = indi.getProperty( new TagPath( "INDI:BIRT:PLAC" ));
		String strBPlace = null;
		if( null != bPlace ) {
			strBPlace = bPlace.getValue();
		}
		Property dPlace = indi.getProperty( new TagPath( "INDI:DEAT:PLAC" ));
		String strDPlace = null;
		if( null != dPlace ) {
			strDPlace = dPlace.getValue();
		}
		
		out += "b: " + indi.getBirthAsString() +
			( 0 != strBPlace.compareTo("") ? " in " + strBPlace : "" ) +
			" - d: " + indi.getDeathAsString() +
			( 0 != strDPlace.compareTo("") ? " in " + strDPlace : "" ) +
			"<br>";
		return out;
	}
	
	/**
	 * Get Emigration and Immigration info for an Individual.
	 */
	private String getMigrationInfo( Indi indi ) {
		String out = "";
		Property pEMIG = indi.getProperty( "EMIG" );
		Property pIMMI = indi.getProperty( "IMMI" );
			
		if( pEMIG != null || pIMMI != null ) {
			if( pEMIG != null ) {
				Property pEMIGPlace = pEMIG.getProperty( "PLAC" );
				Property pEMIGDate = pEMIG.getProperty( "DATE" );
				out += "Emigrated";
				if( pEMIGPlace.getValue().compareTo("") != 0 ) {
					out += " from " + pEMIGPlace.getValue();
				}
				if( pEMIGDate.getValue().compareTo("") != 0 ) {
					out += " on " + pEMIGDate.getValue();
				}
				out += "<br>";
				Property[] pEMIGNotes = pEMIG.getProperties( "NOTE" );
				if( pEMIGNotes.length > 0 ) {
					out += "<ul>";
					for( int j = 0; j < pEMIGNotes.length; j++ ) {
						if( pEMIGNotes[j] instanceof PropertyMultilineValue ) {
							PropertyMultilineValue pn = ( PropertyMultilineValue ) pEMIGNotes[j];
							out += "<li><pre>" + pn.getLinesValue() + "</pre>";
						}
					}
					out += "</ul>";
				}
			}
			
			if( pIMMI != null ) {
				Property pIMMIPlace = pIMMI.getProperty( "PLAC" );
				Property pIMMIDate = pIMMI.getProperty( "DATE" );
				out += "Immigrated";
				if( pIMMIPlace.getValue().compareTo("") != 0 ) {
					out += " to " + pIMMIPlace.getValue();
				}
				if( pIMMIDate.getValue().compareTo("") != 0 ) {
					out += " on " + pIMMIDate.getValue();
				}
				out += "<br>";
				Property[] pIMMINotes = pIMMI.getProperties( "NOTE" );
				if( pIMMINotes.length > 0 ) {
					out += "<ul>";
					for( int j = 0; j < pIMMINotes.length; j++ ) {
						if( pIMMINotes[j] instanceof PropertyMultilineValue ) {
							PropertyMultilineValue pn = ( PropertyMultilineValue ) pIMMINotes[j];
							out += "<li><pre>" + pn.getLinesValue() + "</pre>";
						}
					}
					out += "</ul>";
				}
			}
			out += "<hr>";
		}
			
		return out;
	}
	
	/**
	 * Return parents and siblings for an Individual.
	 */
	private String getParentsInfo( Indi indi ) {
		String out = "";
		Fam famParents = indi.getFamc();
		if( null == famParents ) {
			out += "Child of [Unknown] and [Unknown]<br>";
		} else {
			Indi father = famParents.getHusband();
			Indi mother = famParents.getWife();
			TreeSet tsSiblings = new TreeSet();
			out += "Child of ";
			if( null == father ) {
				out += "[Unknown] and ";
			} else {
				out += "<A HREF=\"../../../" + getIndiHtml( father.getId()) + "\">" +
					father.getName() + "</A> and ";
				Indi[] fsibs = father.getChildren();
				for( int i = 0; i < fsibs.length; i++ ) {
					tsSiblings.add( fsibs[i] );
				}
			}
			if( null == mother ) {
				out += "[Unknown]<br>";
			} else {
				out += "<A HREF=\"../../../" + getIndiHtml( mother.getId()) + "\">" +
					mother.getName() + "</A><br>";
				Indi[] fsibs = mother.getChildren();
				for( int i = 0; i < fsibs.length; i++ ) {
					tsSiblings.add( fsibs[i] );
				}
			}
			if( tsSiblings.size() > 1 ) {
				out += "Siblings are <br><ul>";
				Iterator iSibs = tsSiblings.iterator();
				while( iSibs.hasNext() ) {
					Indi child = (Indi) iSibs.next();
					if( ! child.getId().equals( indi.getId() )) {
						out += "<li><a href=\"../../../" +
							getIndiHtml( child.getId()) + "\">" +
							child.getName() + "</a></li>";
					}
				}
				out += "</ul>";
			}
		}
		return out;
	}
	
	/**
	 * Return spouses and children for an Individual.
	 */
	private String getSpouseInfo( Indi indi ) {
		String out = "";
		Fam[] famSpouses = indi.getFamilies();
		for( int i = 0; i < famSpouses.length; i++ ) {
			out += "<hr>Marriage " + (i + 1) + "<br>";
			String marriageDate = "[Unknown]";
			if( null != famSpouses[i].getMarriageDate() ) {
				marriageDate = famSpouses[i].getMarriageDate().toString();
			}
			String spouseName = "[Unknown]";
			if( null != famSpouses[i].getOtherSpouse(indi) ) {
				spouseName = famSpouses[i].getOtherSpouse(indi).getName();
			}
			out += spouseName + " " + marriageDate + "<br>";
			Indi[] children = famSpouses[i].getChildren();
			if( children.length > 0 ) {
				out += "Children:<ul>";
				for( int j = 0; j < children.length; j++ ) {
					out += "<li><a href=\"../../../" +
						getIndiHtml( children[j].getId()) + "\">" +
						children[j].getName() + "</a></li>";
				}
				out += "</ul>";
			}
		}
		return out;
	}
	
	/**
	 * Return notes for this Individual.
	 */
	private String getNotesInfo( Indi indi ) {
		String out = "";
		Property[] props = indi.getProperties( "NOTE" );
		if( props.length > 0 ) {
			out += "<hr>Notes:<br>";
		}
		for( int j = 0; j < props.length; j++ ) {
			if( props[j] instanceof PropertyMultilineValue ) {
				PropertyMultilineValue pn = ( PropertyMultilineValue ) props[j];
				out += pn.getLinesValue() + "<br>";
			}
		}
		return out;
	}
	
	/**
	 * Write an individual's HTML file.  This version uses report properties
	 * as HTML templates.
	 */
	private void writeIndiHTML( Indi indi ) {
		String pathSep = System.getProperty( "file.separator" );
		String outName = strOutputDir + pathSep + getIndiHtml( indi.getId() );
		// Figure out the directory that this file will reside in, and create
		// it.  FileOutputStream doesn't do this for us...
		int last = outName.lastIndexOf( '/' );
		if( -1 == last ) {
			println( "Error: Could not find last '/' in " + outName );
			return;
		}
		
		// If the output file exists, don't try re-writing it.  This should
		// close Bug 2.
		File f0 = new File( outName );
		if( f0.exists() ) {
			// println( outName + " already exists.  Bailing." );
			return;
		}
		
		String outDir = outName.substring( 0, last );
		File f1 = new File( outDir );
		f1.mkdirs();
		OutputStream os = null;
		try {
			os = new FileOutputStream( outName );
			PrintWriter pw = new PrintWriter( os );
			
			StringBuffer document = new StringBuffer( i18n( "htmldoc" ));
			String strDoc = document.toString();
			int pos, endpos;
			
			// block tags first
			pos = strDoc.indexOf( "{block_nationality}" );
			while( pos != -1 ) {
				endpos = pos + 19;
				String strRep;
				if( hasNationality( indi )) {
					strRep = i18n( "block_nationality" );
				} else {
					if( i18n( "block_nationality_notext" ).equals(
					  "block_nationality_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_nationality_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_nationality}" );
			}
			pos = strDoc.indexOf( "{block_migration}" );
			while( pos != -1 ) {
				endpos = pos + 17;
				String strRep;
				if( hasEmigration( indi ) || hasImmigration( indi )) {
					strRep = i18n( "block_migration" );
				} else {
					if( i18n( "block_migration_notext" ).equals(
					  "block_migration_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_migration_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_migration}" );
			}
			pos = strDoc.indexOf( "{block_emigration}" );
			while( pos != -1 ) {
				endpos = pos + 18;
				String strRep;
				if( hasEmigration( indi )) {
					strRep = i18n( "block_emigration" );
				} else {
					if( i18n( "block_emigration_notext" ).equals(
					  "block_emigration_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_emigration_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_emigration}" );
			}
			pos = strDoc.indexOf( "{block_emigration_place}" );
			while( pos != -1 ) {
				endpos = pos + 24;
				String strRep;
				if( hasEmigrationPlace( indi )) {
					strRep = i18n( "block_emigration_place" );
				} else {
					if( i18n( "block_emigration_place_notext" ).equals(
					  "block_emigration_place_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_emigration_place_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_emigration_place}" );
			}
			pos = strDoc.indexOf( "{block_emigration_date}" );
			while( pos != -1 ) {
				endpos = pos + 23;
				String strRep;
				if( hasEmigrationDate( indi )) {
					strRep = i18n( "block_emigration_date" );
				} else {
					if( i18n( "block_emigration_date_notext" ).equals(
					  "block_emigration_date_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_emigration_date_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_emigration_date}" );
			}
			pos = strDoc.indexOf( "{block_emigration_notes}" );
			while( pos != -1 ) {
				endpos = pos + 24;
				String strRep;
				if( hasEmigrationNotes( indi )) {
					strRep = i18n( "block_emigration_notes" );
				} else {
					if( i18n( "block_emigration_notes_notext" ).equals(
					  "block_emigration_notes_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_emigration_notes_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_emigration_notes}" );
			}
			pos = strDoc.indexOf( "{block_immigration}" );
			while( pos != -1 ) {
				endpos = pos + 19;
				String strRep;
				if( hasImmigration( indi )) {
					strRep = i18n( "block_immigration" );
				} else {
					if( i18n( "block_immigration_notext" ).equals(
					  "block_immigration_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_immigration_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_immigration}" );
			}
			pos = strDoc.indexOf( "{block_immigration_place}" );
			while( pos != -1 ) {
				endpos = pos + 25;
				String strRep;
				if( hasImmigrationPlace( indi )) {
					strRep = i18n( "block_immigration_place" );
				} else {
					if( i18n( "block_immigration_place_notext" ).equals(
					  "block_immigration_place_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_immigration_place_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_immigration_place}" );
			}
			pos = strDoc.indexOf( "{block_immigration_date}" );
			while( pos != -1 ) {
				endpos = pos + 24;
				String strRep;
				if( hasImmigrationDate( indi )) {
					strRep = i18n( "block_immigration_date" );
				} else {
					if( i18n( "block_immigration_date_notext" ).equals(
					  "block_immigration_date_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_immigration_date_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_immigration_date}" );
			}
			pos = strDoc.indexOf( "{block_immigration_notes}" );
			while( pos != -1 ) {
				endpos = pos + 25;
				String strRep;
				if( hasImmigrationNotes( indi )) {
					strRep = i18n( "block_immigration_notes" );
				} else {
					if( i18n( "block_immigration_notes_notext" ).equals(
					  "block_immigration_notes_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_immigration_notes_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_immigration_notes}" );
			}
			pos = strDoc.indexOf( "{block_description}" );
			while( pos != -1 ) {
				endpos = pos + 19;
				String strRep;
				if( hasDescription( indi )) {
					strRep = i18n( "block_description" );
				} else {
					if( i18n( "block_description_notext" ).equals(
					  "block_description_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_description_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_description}" );
			}
			pos = strDoc.indexOf( "{block_birthplace}" );
			while( pos != -1 ) {
				endpos = pos + 18;
				String strRep;
				if( hasBirthPlace( indi )) {
					strRep = i18n( "block_birthplace" );
				} else {
					if( i18n( "block_birthplace_notext" ).equals(
					  "block_birthplace_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_birthplace_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_birthplace}" );
			}
			pos = strDoc.indexOf( "{block_deathplace}" );
			while( pos != -1 ) {
				endpos = pos + 18;
				String strRep;
				if( hasDeathPlace( indi )) {
					strRep = i18n( "block_deathplace" );
				} else {
					if( i18n( "block_deathplace_notext" ).equals(
					  "block_deathplace_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_deathplace_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_deathplace}" );
			}
			pos = strDoc.indexOf( "{block_aliases}" );
			while( pos != -1 ) {
				endpos = pos + 15;
				String strRep;
				if( hasAliases( indi )) {
					strRep = i18n( "block_aliases" );
				} else {
					if( i18n( "block_aliases_notext" ).equals(
					  "block_aliases_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_aliases_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_aliases}" );
			}
			pos = strDoc.indexOf( "{block_notes}" );
			while( pos != -1 ) {
				endpos = pos + 13;
				String strRep;
				if( hasNotes( indi )) {
					strRep = i18n( "block_notes" );
				} else {
					if( i18n( "block_notes_notext" ).equals(
					  "block_notes_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_notes_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_notes}" );
			}
			pos = strDoc.indexOf( "{block_father}" );
			while( pos != -1 ) {
				endpos = pos + 14;
				String strRep;
				if( hasFather( indi )) {
					strRep = i18n( "block_father" );
				} else {
					if( i18n( "block_father_notext" ).equals(
					  "block_father_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_father_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_father}" );
			}
			pos = strDoc.indexOf( "{block_mother}" );
			while( pos != -1 ) {
				endpos = pos + 14;
				String strRep;
				if( hasMother( indi )) {
					strRep = i18n( "block_mother" );
				} else {
					if( i18n( "block_mother_notext" ).equals(
					  "block_mother_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_mother_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_mother}" );
			}
			pos = strDoc.indexOf( "{block_spouses}" );
			while( pos != -1 ) {
				if( DEBUG ) {
					println( "  {block_spouses} loop starts" );
				}
				endpos = pos + 15;	// length of {block_spouses}
				String strRep;
				if( hasSpouses( indi )) {
					strRep = i18n( "block_spouses" );
				} else {
					if( i18n( "block_spouses_notext" ).equals(
					  "block_spouses_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_spouses_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_spouses}" );
				if( DEBUG ) {
					println( "   {block_spouses} loop next" );
				}
			}
			if( DEBUG ) {
				println( "  {block_spouses} loop ends" );
			}
			pos = strDoc.indexOf( "{block_siblings}" );
			while( pos != -1 ) {
				endpos = pos + 16;	// length of {block_siblings}
				String strRep;
				if( hasSiblings( indi )) {
					strRep = i18n( "block_siblings" );
				} else {
					if( i18n( "block_siblings_notext" ).equals(
					  "block_siblings_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_siblings_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_siblings}" );
			}
			pos = strDoc.indexOf( "{block_children}" );
			while( pos != -1 ) {
				endpos = pos + 16;	// length of {block_children}
				String strRep;
				if( hasChildren( indi )) {
					strRep = i18n( "block_children" );
				} else {
					if( i18n( "block_children_notext" ).equals(
					  "block_children_notext" )) {
						strRep = "";
					} else {
						strRep = i18n( "block_children_notext" );
					}
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{block_children}" );
			}
			
			// list headers next
			pos = strDoc.indexOf( "{list_aliases}" );
			while( pos != -1 ) {
				endpos = pos + 14;	// length of {list_aliases}
				document.replace( pos, endpos, i18n( "list_aliases" ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{list_aliases}" );
			}
			pos = strDoc.indexOf( "{list_notes}" );
			while( pos != -1 ) {
				endpos = pos + 12;	// length of {list_notes}
				document.replace( pos, endpos, i18n( "list_notes" ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{list_notes}" );
			}
			pos = strDoc.indexOf( "{list_immigration_notes}" );
			while( pos != -1 ) {
				endpos = pos + 24;	// length of {list_immigration_notes}
				document.replace( pos, endpos, i18n( "list_immigration_notes" ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{list_immigration_notes}" );
			}
			pos = strDoc.indexOf( "{list_emigration_notes}" );
			while( pos != -1 ) {
				endpos = pos + 23;	// length of {list_emigration_notes}
				document.replace( pos, endpos, i18n( "list_emigration_notes" ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{list_emigration_notes}" );
			}
			pos = strDoc.indexOf( "{list_siblings}" );
			while( pos != -1 ) {
				endpos = pos + 15;	// length of {list_siblings}
				document.replace( pos, endpos, i18n( "list_siblings" ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{list_siblings}" );
			}
			pos = strDoc.indexOf( "{list_children}" );
			while( pos != -1 ) {
				endpos = pos + 15;	// length of {list_children}
				document.replace( pos, endpos, i18n( "list_children" ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{list_children}" );
			}
			pos = strDoc.indexOf( "{list_spouses}" );
			while( pos != -1 ) {
				endpos = pos + 14;	// length of {list_spouses}
				document.replace( pos, endpos, i18n( "list_spouses" ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{list_spouses}" );
			}
			
			// now, list elements
			pos = strDoc.indexOf( "{aliases}" );
			while( pos != -1 ) {
				endpos = pos + 9;	// length of {aliases}
				String strRep = "";
				String aa[] = getAliases( indi );
				for( int i = 0; i < aa.length; i++ ) {
					String strTmp = i18n( "aliases" );
					StringBuffer docTmp = new StringBuffer( strTmp );
					int p2 = strTmp.indexOf( "{alias}" );
					while( p2 != -1 ) {
						int ep2 = p2 + 7;	// length of {alias}
						docTmp.replace( p2, ep2, aa[i] );
						strTmp = docTmp.toString();
						p2 = strTmp.indexOf( "{alias}" );
					}
					strRep += strTmp;
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{aliases}" );
			}
			pos = strDoc.indexOf( "{notes}" );
			while( pos != -1 ) {
				endpos = pos + 7;	// length of {notes}
				String strRep = "";
				String aa[] = getNotes( indi );
				for( int i = 0; i < aa.length; i++ ) {
					String strTmp = i18n( "notes" );
					StringBuffer docTmp = new StringBuffer( strTmp );
					int p2 = strTmp.indexOf( "{note}" );
					while( p2 != -1 ) {
						int ep2 = p2 + 6;	// length of {note}
						docTmp.replace( p2, ep2, aa[i] );
						strTmp = docTmp.toString();
						p2 = strTmp.indexOf( "{note}" );
					}
					strRep += strTmp;
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{notes}" );
			}
			pos = strDoc.indexOf( "{emigration_notes}" );
			while( pos != -1 ) {
				endpos = pos + 18;	// length of {emigration_notes}
				String strRep = "";
				String aa[] = getEmigrationNotes( indi );
				for( int i = 0; i < aa.length; i++ ) {
					String strTmp = i18n( "emigration_notes" );
					StringBuffer docTmp = new StringBuffer( strTmp );
					int p2 = strTmp.indexOf( "{emigration_note}" );
					while( p2 != -1 ) {
						int ep2 = p2 + 17;	// length of {emigration_note}
						docTmp.replace( p2, ep2, aa[i] );
						strTmp = docTmp.toString();
						p2 = strTmp.indexOf( "{emigration_note}" );
					}
					strRep += strTmp;
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{emigration_notes}" );
			}
			pos = strDoc.indexOf( "{immigration_notes}" );
			while( pos != -1 ) {
				endpos = pos + 19;	// length of {immigration_notes}
				String strRep = "";
				String aa[] = getImmigrationNotes( indi );
				for( int i = 0; i < aa.length; i++ ) {
					String strTmp = i18n( "immigration_notes" );
					StringBuffer docTmp = new StringBuffer( strTmp );
					int p2 = strTmp.indexOf( "{immigration_note}" );
					while( p2 != -1 ) {
						int ep2 = p2 + 18;	// length of {immigration_note}
						docTmp.replace( p2, ep2, aa[i] );
						strTmp = docTmp.toString();
						p2 = strTmp.indexOf( "{immigration_note}" );
					}
					strRep += strTmp;
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{immigration_notes}" );
			}
			pos = strDoc.indexOf( "{siblings}" );
			while( pos != -1 ) {
				endpos = pos + 10;	// length of {siblings}
				String strRep = "";
				TreeSet ts = getSiblings( indi );
				Iterator iSibs = ts.iterator();
				while( iSibs.hasNext() ) {
					Indi sib = (Indi)iSibs.next();
					String strTmp = i18n( "siblings" );
					StringBuffer docTmp = new StringBuffer( strTmp );
					int p2 = strTmp.indexOf( "{link_sibling}" );
					while( p2 != -1 ) {
						int ep2 = p2 + 14;	// length of {link_sibling}
						Object[] repText = {
							"../../../" + getIndiHtml( sib.getId()),
							sib.getName() };
						docTmp.replace( p2, ep2, i18n( "link_sibling", repText ));
						strTmp = docTmp.toString();
						p2 = strTmp.indexOf( "{link_sibling}" );
					}
					strRep += strTmp;
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{siblings}" );
			}
			pos = strDoc.indexOf( "{children}" );
			while( pos != -1 ) {
				endpos = pos + 10;	// length of {children}
				String strRep = "";
				TreeSet ts = getChildren( indi );
				Iterator iKids = ts.iterator();
				while( iKids.hasNext() ) {
					Indi kid = (Indi)iKids.next();
					String strTmp = i18n( "children" );
					StringBuffer docTmp = new StringBuffer( strTmp );
					int p2 = strTmp.indexOf( "{link_child}" );
					while( p2 != -1 ) {
						int ep2 = p2 + 12;	// length of {link_child}
						Object[] repText = {
							"../../../" + getIndiHtml( kid.getId()),
							kid.getName() };
						docTmp.replace( p2, ep2, i18n( "link_child", repText ));
						strTmp = docTmp.toString();
						p2 = strTmp.indexOf( "{link_child}" );
					}
					strRep += strTmp;
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{children}" );
			}
			pos = strDoc.indexOf( "{spouses}" );
			while( pos != -1 ) {
				endpos = pos + 9;	// length of {spouses}
				String strRep = "";
				TreeSet ts = getSpouses( indi );
				Iterator iSps = ts.iterator();
				while( iSps.hasNext() ) {
					Indi sps = (Indi)iSps.next();
					String strTmp = i18n( "spouses" );
					StringBuffer docTmp = new StringBuffer( strTmp );
					int p2 = strTmp.indexOf( "{link_spouse}" );
					while( p2 != -1 ) {
						int ep2 = p2 + 13;	// length of {link_spouse}
						Object[] repText = {
							"../../../" + getIndiHtml( sps.getId()),
							sps.getName() };
						docTmp.replace( p2, ep2, i18n( "link_spouse", repText ));
						strTmp = docTmp.toString();
						p2 = strTmp.indexOf( "{link_spouse}" );
					}
					strRep += strTmp;
				}
				document.replace( pos, endpos, strRep );
				strDoc = document.toString();
				pos = strDoc.indexOf( "{spouses}" );
			}
			
			// now, link elements
			pos = strDoc.indexOf( "{link_father}" );
			while( pos != -1 ) {
				endpos = pos + 13;	// length of '{link_father}'
				document.replace( pos, endpos, i18n( "link_father" ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{link_father}" );
			}
			pos = strDoc.indexOf( "{link_mother}" );
			while( pos != -1 ) {
				endpos = pos + 13;	// length of '{link_mother}'
				document.replace( pos, endpos, i18n( "link_mother" ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{link_mother}" );
			}
			
			// HREF elements
			pos = strDoc.indexOf( "{href_father}" );
			while( pos != -1 ) {
				endpos = pos + 13;	// length of '{href_father}'
				document.replace( pos, endpos, getFatherHref( indi ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{href_father}" );
			}
			pos = strDoc.indexOf( "{href_mother}" );
			while( pos != -1 ) {
				endpos = pos + 13;	// length of '{href_mother}'
				document.replace( pos, endpos, getMotherHref( indi ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{href_mother}" );
			}

			// endnode tags last
			pos = strDoc.indexOf( "{name}" );
			while( pos != -1 ) {
				endpos = pos + 6;	// length of '{name}'
				document.replace( pos, endpos, getName( indi ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{name}" );
			}
			pos = strDoc.indexOf( "{entityID}" );
			while( pos != -1 ) {
				endpos = pos + 10;	// length of {entityID}
				document.replace( pos, endpos, getEntityID( indi ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{entityID}" );
			}
			pos = strDoc.indexOf( "{nationality}" );
			while( pos != -1 ) {
				endpos = pos + 13;	// length of {nationality}
				document.replace( pos, endpos, getNationality( indi ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{nationality}" );
			}
			pos = strDoc.indexOf( "{birthdate}" );
			while( pos != -1 ) {
				endpos = pos + 11;	// length of {birthdate}
				document.replace( pos, endpos, getBirthDate( indi ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{birthdate}" );
			}
			pos = strDoc.indexOf( "{deathdate}" );
			while( pos != -1 ) {
				endpos = pos + 11;	// length of {deathdate}
				document.replace( pos, endpos, getDeathDate( indi ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{deathdate}" );
			}
			pos = strDoc.indexOf( "{birthplace}" );
			while( pos != -1 ) {
				endpos = pos + 12;	// length of {birthplace}
				document.replace( pos, endpos, getBirthPlace( indi ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{birthplace}" );
			}
			pos = strDoc.indexOf( "{deathplace}" );
			while( pos != -1 ) {
				endpos = pos + 12;	// length of {deathplace}
				document.replace( pos, endpos, getDeathPlace( indi ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{deathplace}" );
			}
			pos = strDoc.indexOf( "{description}" );
			while( pos != -1 ) {
				endpos = pos + 13;	// length of {description}
				document.replace( pos, endpos, getDescription( indi ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{description}" );
			}
			pos = strDoc.indexOf( "{emigration_place}" );
			while( pos != -1 ) {
				endpos = pos + 18;	// length of {emigration_place}
				document.replace( pos, endpos, getEmigrationPlace( indi ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{emigration_place}" );
			}
			pos = strDoc.indexOf( "{immigration_place}" );
			while( pos != -1 ) {
				endpos = pos + 19;	// length of {immigration_place}
				document.replace( pos, endpos, getImmigrationPlace( indi ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{immigration_place}" );
			}
			pos = strDoc.indexOf( "{emigration_date}" );
			while( pos != -1 ) {
				endpos = pos + 17;	// length of {emigration_date}
				document.replace( pos, endpos, getEmigrationDate( indi ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{emigration_date}" );
			}
			pos = strDoc.indexOf( "{immigration_date}" );
			while( pos != -1 ) {
				endpos = pos + 18;	// length of {immigration_date}
				document.replace( pos, endpos, getImmigrationDate( indi ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{immigration_date}" );
			}
			pos = strDoc.indexOf( "{father}" );
			while( pos != -1 ) {
				endpos = pos + 8;	// length of {father}
				document.replace( pos, endpos, getFatherName( indi ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{father}" );
			}
			pos = strDoc.indexOf( "{mother}" );
			while( pos != -1 ) {
				endpos = pos + 8;	// length of {mother}
				document.replace( pos, endpos, getMotherName( indi ));
				strDoc = document.toString();
				pos = strDoc.indexOf( "{mother}" );
			}
			
			pw.println( document );
			pw.close();
		} catch( Exception e ) {
			println( "(" + indi.getId() + "): Caught exception: " + e );
			e.printStackTrace();
		}
	}

	/**
	 * Write an individual's HTML file.  This is the old archival version.
	 * This will be removed once all the templated crap is working to my
	 * satisfaction.
	 * @param indi The individual for which an HTML file will be written.
	 */
	private void writeIndiHTML_old( Indi indi ) {
		// println( "Dump: " + indi.getId() );
		String pathSep = System.getProperty( "file.separator" );
		String outName = strOutputDir + pathSep + getIndiHtml( indi.getId() );
		// Figure out the directory that this file will reside in, and create
		// it.  FileOutputStream doesn't do this for us...
		int last = outName.lastIndexOf( '/' );
		if( -1 == last ) {
			println( "Error: Could not find last '/' in " + outName );
			return;
		}
		
		// If the output file exists, don't try re-writing it.  This should
		// close Bug 2.
		File f0 = new File( outName );
		if( f0.exists() ) {
			// println( outName + " already exists.  Bailing." );
			return;
		}
		
		String outDir = outName.substring( 0, last );
		File f1 = new File( outDir );
		f1.mkdirs();
		OutputStream os = null;
		try {
			os = new FileOutputStream( outName );
			PrintWriter pw = new PrintWriter( os );
			pw.println( "<HTML>" );
			pw.println( "<HEAD>" );
			pw.println( "<TITLE>" + indi.getName() + "</TITLE>" );
			pw.println( "</HEAD><BODY>" );
			pw.println( getNameInfo( indi ));
			pw.println( getBirthDeathInfo( indi ));
			pw.println( "<hr>" );
			
			pw.println( getMigrationInfo( indi ));
			
			// Get parents and siblings.
			pw.println( getParentsInfo( indi ));
			
			// Get spouses and children.
			pw.println( getSpouseInfo( indi ));
			
			// Any notes on this entity?
			pw.println( getNotesInfo( indi ));
			
			// Any multimedia objects?
			Property[] props = indi.getProperties( "OBJE" );
			if( props.length > 0 ) {
				pw.println( "<hr>Multimedia:<br>" );
			}
			for( int j = 0; j < props.length; j++ ) {
				if( props[j] instanceof PropertyMedia ) {
					PropertyMedia pm = ( PropertyMedia ) props[j];
					Property filename = pm.getProperty( "FILE" );
					if( 0 != filename.getValue().compareTo( "" )) {
						println( "FileName = " + filename.getValue() );
						Property filetype = pm.getProperty( "FORM" );
						println( "FileType = " + filetype.getValue() );
						Property filetitle = pm.getProperty( "TITL" );
						String outFName = strOutputDir + pathSep + getIndiHtml( indi.getId() );
						int n = outFName.lastIndexOf( '.' );
						String outThumb = outFName.substring( 0, n ) + "_" +
							j + ".thumb." + filetype.getValue();
						outFName = outFName.substring( 0, n ) + "_" + j + "." +
							filetype.getValue();
						println( "OutFile = " + outFName );
						println( "OutThumb = " + outThumb );
						n = outFName.lastIndexOf( '/' );
						String htmlName = outFName.substring( n+1 );
						n = outThumb.lastIndexOf( '/' );
						String htmlThumb = outThumb.substring( n+1 );
						println( "HTMLFile = " + htmlName );
						Origin o = indi.getGedcom().getOrigin();
						InputStream is = o.open( filename.getValue() );
						FileOutputStream fos = new FileOutputStream( outFName );
						byte buffer[] = new byte[100];
						int nRead = 0;
						do {
							nRead = is.read( buffer );
							if( nRead != -1 ) {
								fos.write( buffer, 0, nRead );
							}
						} while( nRead != -1 );
						is.close();
						fos.close();
						createThumbnail( outFName, outThumb, THUMB_SIZE );
//						pw.println("<img src=\"" + htmlName + "\" title = \"" +
//							filetitle.getValue() + "\"><br>" );
						pw.println( "<a href=\"" + htmlName + "\" " +
							"\" target=\"_newwin\">" +
							"<img src=\"" + htmlThumb + "\" title=\"" +
							filetitle.getValue() + "\"></a><br>" );
					}
				}
			}
			
			pw.println( "</BODY></HTML>" );
			pw.close();
		} catch( Exception e ) {
			println( "(" + indi.getId() + "): Caught exception: " + e );
			e.printStackTrace( System.out );
		}
	}
	
	/**
	 * Write the generic HTML files used for this report.
	 */
	private void buildHtmlSkeleton() {
		String pathSep = System.getProperty( "file.separator" );
		String index_html = strOutputDir + pathSep + "index.html";
		println( "Creating file: " + index_html );
		String tree_html = strOutputDir + pathSep + "_tree.html";
		println( "Creating file: " + tree_html );
		String intro_html = strOutputDir + pathSep + "_intro.html";
		println( "Creating file: " + intro_html );
		OutputStream os = null;
		try {
			os = new FileOutputStream( index_html );
			PrintWriter pw = new PrintWriter( os );
			pw.println( "<HTML>" );
			pw.println( "<HEAD>" );
			pw.println( "<TITLE>Family Viewer</TITLE>" );
			pw.println( "<SCRIPT>" );
			pw.println( "function op() {" );
			pw.println( "}" );
			pw.println( "</SCRIPT>" );
			pw.println( "</HEAD>" );
			pw.println( "<FRAMESET cols=\"300,*\" onResize=\"if (navigator.family == 'NN4') window.location.reload\">" );
			pw.println( "  <FRAME src=\"_tree.html\" name=\"treeframe\">" );
			pw.println( "  <FRAME src=\"_intro.html\" name=\"basefrm\">" );
			pw.println( "</FRAMESET>" );
			pw.println( "</HTML>" );
			pw.close();
		} catch( Exception e ) {
			println( "(index.html) Caught exception: " + e );
		}
		os = null;
		try {
			os = new FileOutputStream( tree_html );
			PrintWriter pw = new PrintWriter( os );
			pw.println( "<HTML>" );
			pw.println( "<HEAD>" );
			pw.println( "<STYLE>" );
			pw.println( "  BODY {background-color: white}" );
			pw.println( "  TD {font-size: 10pt;" );
			pw.println( "      font-family: verdana,helvetica;" );
			pw.println( "      white-space:nowrap;}" );
			pw.println( "  A  {text-decoration: none;" );
			pw.println( "      color: black)" );
			pw.println();
			pw.println( "   .specialClass {font-family:garamond; font-size:12pt;color:green;font-weight:bold;text-decoration:underline}" );
			pw.println( "</STYLE>" );
			pw.println( "<SCRIPT src=\"std/ua.js\"></SCRIPT>" );
			pw.println( "<SCRIPT src=\"std/ftiens4.js\"></SCRIPT>" );
			pw.println( "<SCRIPT src=\"Nodes.js\"></SCRIPT>" );
			pw.println( "</HEAD>" );
			pw.println( "<BODY topmargin=16 marginheight=16>" );
			pw.println( "<div style=\"position:absolute; top:0; left:0; \">" );
			pw.println( "<table border=0><tr><td><font size=-2>" );
			pw.println( "<a style=\"font-size:7pt;text-decoration:none;color:silver\" href=\"http://www.treemenu.net/\" target=_blank>JavaScript Tree Menu</a>" );
			pw.println( "</font></td></tr></table></div>" );
			pw.println( "<SCRIPT>initializeDocument()</SCRIPT>" );
			pw.println( "<NOSCRIPT>" );
			pw.println( "A tree for site navigation will open here if you enable JavaScript in your browser." );
			pw.println( "</NOSCRIPT>" );
			pw.println( "</HTML>" );
			pw.close();
		} catch( Exception e ) {
			println( "(_tree.html) Caught exception: " + e );
		}
		os = null;
		try {
			os = new FileOutputStream( intro_html );
			PrintWriter pw = new PrintWriter( os );
			pw.println( "<HTML>" );
			pw.println( "<HEAD></HEAD>" );
			pw.println( "<BODY>" );
			pw.println( "<FONT size=+2>" );
			pw.println( "The tree may take a moment to render.  Please be patient." );
			pw.println( "</FONT>" );
			pw.println( "<br><br><br>" );
			pw.println( "This genealogy database was created and modified using " );
			pw.println( "<A HREF=\"http://genj.sourceforge.net\" target=_blank>GenJ 2.1</A><br>" );
			pw.println( "This report is " + getName() + ", " + getVersion());
			pw.println( ", copyright &copy; 2003 Michael Collins<br>" );
			pw.println( "Tree control courtesy of " );
			pw.println( "<A HREF=\"http://www.treeview.net\" target=_blank>TreeView 4.3</A><br>" );
			pw.println( "<br><br>" );
			pw.println( "Questions or comments should be directed to the authors:<br>" );
			pw.println( "<A HREF=\"mailto:mikec01b@netscape.net\">Michael Collins</A><br>" );
			pw.println( "<A HREF=\"mailto:mpfaff@charter.net\">Morgan Pfaff</A><br>" );
			pw.println( "<br><br><br>" );
			pw.println( "</BODY>" );
			pw.println( "</HTML>" );
			pw.close();
		} catch( Exception e ) {
			println( "(_intro.html) Caught exception: " + e );
		}
	}
		
	/**
	 * Helper that indents to given level
	 * @param level The level to indent to.
	 * @return String A string with an appropriate number of spaces
	 *  for the indent level.
	 */
	private String getIndent(int level) {
		StringBuffer buffer = new StringBuffer(256);
		while (--level>0) {
			buffer.append("    ");
		}
		return buffer.toString();
	}

	/**
	 * Deletes all files and subdirectories beneath the directory
	 * specified.
	 * @param dir The directory to remove.
	 * @return boolean true for success, false for failure.
	 */
	private boolean deleteDir( File dir ) {
		if( dir.isDirectory() ) {
			String[] children = dir.list();
			for( int i = 0; i < children.length; i++ ) {
				boolean success = deleteDir( new File( dir, children[i] ));
				if( !success ) {
					return false;
				}
			}
		}
		return dir.delete();
	}
	
	/**
	 * This will create a thumbnail image given a full-size image.
	 * This code retrieved from
	 * <http://java.sun.com/developer/TechTips/1999/tt1021.html>
	 * (Sun JDC Tech Tips, October 21, 1999).
	 *
	 * @param orig The name of the original image file.
	 * @param thumb The name of the output thumbnail image file.
	 * @param maxDim Specifies the desired height/width of the new image.
	 */
	private void createThumbnail( String orig, String thumb, int maxDim ) {
		try {
			// get the image from a file.
			Image inImage = new ImageIcon(orig).getImage();
			
			// determine the scale.
			double scale = (double)maxDim / (double)inImage.getHeight(null);
			if( inImage.getWidth(null) > inImage.getHeight(null) ) {
				scale = (double)maxDim / (double)inImage.getWidth(null);
			}
			
			// determine the size of the new image.  One of these numbers
			// should equal maxDim.
			int scaledW = (int)(scale * inImage.getWidth(null));
			int scaledH = (int)(scale * inImage.getHeight(null));
			
			// create an image buffer for painting.
			BufferedImage outImage = new BufferedImage( scaledW, scaledH,
				BufferedImage.TYPE_INT_RGB );
			
			// set the scale.
			AffineTransform tx = new AffineTransform();
			
			// if the image is smaller than the desired size, don't bother
			// scaling.
			if( scale < 1.0d ) {
				tx.scale( scale, scale );
			}
			
			// paint the image.
			Graphics2D g2d = outImage.createGraphics();
			g2d.drawImage( inImage, tx, null );
			g2d.dispose();
			
			// JPEG-encode this image and write to a file.
			OutputStream os = new FileOutputStream( thumb );
			JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder( os );
			encoder.encode( outImage );
			os.close();
		} catch( IOException e ) {
			e.printStackTrace();
		}
	}
	
} // End of ReportHTMLList class
